<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>日之呼吸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录生活">
<meta property="og:type" content="website">
<meta property="og:title" content="日之呼吸">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="日之呼吸">
<meta property="og:description" content="记录生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zex">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="日之呼吸" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">日之呼吸</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SpringBoot集成RabbitMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/23/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/" class="article-date">
  <time class="dt-published" datetime="2023-08-22T16:03:25.000Z" itemprop="datePublished">2023-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/23/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/">SpringBoot集成RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="RabbitMQ入门教程"><a href="#RabbitMQ入门教程" class="headerlink" title="RabbitMQ入门教程"></a>RabbitMQ入门教程</h1><p>RabbitMQ是一个开源的消息中间件，它可以实现应用程序之间的异步通信，提高系统的可扩展性和可靠性。RabbitMQ支持多种消息协议，如AMQP、MQTT、STOMP等，也提供了多种语言的客户端库，如Java、Python、Ruby等。RabbitMQ的主要特点有：</p>
<ul>
<li>高性能：RabbitMQ可以处理数百万条消息每秒，支持集群和负载均衡。</li>
<li>高可用：RabbitMQ可以通过镜像队列和集群来实现消息的冗余和容错。</li>
<li>高灵活：RabbitMQ可以通过交换机和绑定来实现多种消息路由模式，如直连、主题、广播等。</li>
<li>高扩展：RabbitMQ可以通过插件机制来扩展其功能，如延迟队列、死信队列、优先级队列等。</li>
</ul>
<p>RabbitMQ也有一些缺点，如：</p>
<ul>
<li>学习成本：RabbitMQ涉及到很多概念和配置，需要花一定时间学习和理解。</li>
<li>内存消耗：RabbitMQ会将所有未消费的消息存储在内存中，如果消息堆积过多，可能会导致内存不足或者性能下降。</li>
<li>确认机制：RabbitMQ提供了确认机制来保证消息的可靠传递，但是这也会增加消息的延迟和开销。</li>
</ul>
<h2 id="RabbitMQ的底层原理"><a href="#RabbitMQ的底层原理" class="headerlink" title="RabbitMQ的底层原理"></a>RabbitMQ的底层原理</h2><p>RabbitMQ的核心组件有：</p>
<ul>
<li>生产者（Producer）：负责发送消息到交换机。</li>
<li>交换机（Exchange）：负责根据路由键将消息分发到不同的队列。</li>
<li>队列（Queue）：负责存储和转发消息给消费者。</li>
<li>消费者（Consumer）：负责从队列中接收和处理消息。</li>
</ul>
<p>RabbitMQ的工作流程如下：</p>
<ol>
<li>生产者创建一个连接（Connection）和一个信道（Channel）到RabbitMQ服务器。</li>
<li>生产者声明一个交换机（Exchange）和一个或多个队列（Queue），并将它们绑定（Bind）起来。</li>
<li>生产者发送消息到交换机，并指定一个路由键（Routing Key）。</li>
<li>交换机根据路由键和绑定规则将消息分发到匹配的队列中。</li>
<li>消费者创建一个连接（Connection）和一个信道（Channel）到RabbitMQ服务器。</li>
<li>消费者声明一个或多个队列（Queue），并订阅（Subscribe）它们。</li>
<li>消费者从队列中获取并处理消息，并发送确认（Ack）给RabbitMQ服务器。</li>
</ol>
<h2 id="Spring-Boot集成RabbitMQ的案例"><a href="#Spring-Boot集成RabbitMQ的案例" class="headerlink" title="Spring Boot集成RabbitMQ的案例"></a>Spring Boot集成RabbitMQ的案例</h2><p>以下是一个使用Spring Boot集成RabbitMQ的案例，实现了Comfirm、Return、ACK机制。</p>
<h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>在pom.xml文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在application.yml文件中添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启生产者确认</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启生产者返回</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 开启手动确认</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="string">&lt;!--publisher-confirm-type</span> <span class="string">是一个用来设置发布确认模式的属性，它可以让生产者知道消息是否成功发送到交换器。它有三种可选的值：--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--none：表示禁用发布确认模式，不会触发任何回调方法，也不会等待确认结果。--&gt;</span></span><br><span class="line"><span class="string">&lt;!--correlated：表示使用相关数据（CorrelationData）来关联发送的消息和确认的结果，会触发</span> <span class="string">ConfirmCallback</span> <span class="string">回调方法，可以根据</span> <span class="string">ack</span> <span class="string">参数判断消息是否成功发送。--&gt;</span></span><br><span class="line"><span class="string">&lt;!--simple：表示使用简单的方式来等待确认结果，可以在发送消息后调用</span> <span class="string">waitForConfirms</span> <span class="string">或</span> <span class="string">waitForConfirmsOrDie</span> <span class="string">方法来阻塞等待，也可以触发</span> <span class="string">ConfirmCallback</span> <span class="string">回调方法--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>创建一个User类作为消息实体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>创建一个配置类，可以在Spring容器中创建一个Bean对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxwang.rocketmqdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建配置类，可以初始化一个消息队列的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 定义交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SMS_EXCHANGE=<span class="string">&quot;test_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SMS_QUEUE=<span class="string">&quot;test_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送短信的routingkey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">String</span> <span class="variable">ROUTING_KEY_SMS_SEND</span> <span class="operator">=</span> <span class="string">&quot;key.user.test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建交换机</span></span><br><span class="line">    <span class="meta">@Bean(SMS_EXCHANGE)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(SMS_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="meta">@Bean(SMS_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(SMS_QUEUE).build();</span><br><span class="line">                <span class="comment">// 关联死信队列</span></span><br><span class="line"><span class="comment">//                .withArgument(&quot;x-dead-letter-exchange&quot;,RabbitDeadMQSMSConfig.SMS_EXCHANGE_DEAD)</span></span><br><span class="line"><span class="comment">//                .withArgument(&quot;x-dead-letter-routing-key&quot;,RabbitDeadMQSMSConfig.ROUTING_KEY_SMS_SEND_DEAD)</span></span><br><span class="line">                <span class="comment">// 队列的最大长度，超出的部分之后变为死信</span></span><br><span class="line"><span class="comment">//                .withArgument(&quot;x-max-length&quot;,6).build();</span></span><br><span class="line">        <span class="comment">// 创建队列时统一增加配置，设定消息超时时间</span></span><br><span class="line"><span class="comment">//        return QueueBuilder.durable(SMS_QUEUE).withArgument(&quot;x-message-ttl&quot;,10*1000).build();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建绑定关系</span></span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(<span class="meta">@Qualifier(SMS_EXCHANGE)</span> Exchange exchange, <span class="meta">@Qualifier(SMS_QUEUE)</span> Queue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key.user.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>创建一个Producer类作为消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxwang.rocketmqdemo.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zxwang.rocketmqdemo.config.RabbitMQConfig;</span><br><span class="line"><span class="keyword">import</span> com.zxwang.rocketmqdemo.pojo.User;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQProducer</span>  <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 创建关联数据对象，用于标识消息</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(user.getName());</span><br><span class="line">        <span class="comment">// 发送消息到交换机，指定路由键</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.SMS_EXCHANGE, RabbitMQConfig.ROUTING_KEY_SMS_SEND, user, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认回调方法，用于处理确认结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功，correlationData=&quot;</span> + correlationData);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败，correlationData=&quot;</span> + correlationData + <span class="string">&quot;, cause=&quot;</span> + cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回回调方法，用于处理未路由的消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息未路由，message=&quot;</span> + returnedMessage.getMessage() + <span class="string">&quot;, replyCode=&quot;</span> + returnedMessage.getReplyCode()</span><br><span class="line">                + <span class="string">&quot;, replyText=&quot;</span> + returnedMessage.getReplyText() + <span class="string">&quot;, exchange=&quot;</span> + returnedMessage.getExchange() + <span class="string">&quot;, routingKey=&quot;</span> + returnedMessage.getRoutingKey());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>创建一个Consumer类作为消息消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听指定的队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue.user&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取消息内容</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) messageConverter.fromMessage(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到消息：&quot;</span> + user);</span><br><span class="line">            <span class="comment">// 处理业务逻辑</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 手动确认消息已消费</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 手动拒绝消息，可以设置是否重新入队列</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>创建一个Test类来测试发送和接收消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        producer.send(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，可以看到控制台输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送成功，correlationData=Alice</span><br><span class="line">收到消息：User&#123;name=&#x27;Alice&#x27;, age=20&#125;</span><br></pre></td></tr></table></figure>

<p>如果修改路由键为”key.error”，则会看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息发送成功，correlationData=Alice</span><br><span class="line">消息未路由，message=(Body:&#x27;User&#123;name=&#x27;Alice&#x27;, age=20&#125;&#x27; MessageProperties [headers=&#123;&#125;, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0]), replyCode=312, replyText=NO_ROUTE, exchange=exchange.direct, routingKey=key.error</span><br></pre></td></tr></table></figure>


<p>#总结</p>
<p><img src="/2023/08/23/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/b07ee5fc671e576a6953c473bebda9b.jpg" alt="IMAGE"></p>
<p>这说明RabbitMQ是基于AMQP协议开发，支持事务。但因为使用消息事务会影响性能，而且使用MQ的场景一般都是为了异步解耦。所以这里使用Comfirm、Return、ACK机来确保消息不丢失。我们可以在ACK中添加一些消息消费失败时的补偿机制或者告警。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/23/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/" data-id="cllnaeuh10009vki7cad82qon" data-title="SpringBoot集成RabbitMQ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring-Boot中过滤器，拦截器和控制器通知的区别和使用场景" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/20/Spring-Boot%E4%B8%AD%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="article-date">
  <time class="dt-published" datetime="2023-07-20T10:15:51.000Z" itemprop="datePublished">2023-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/20/Spring-Boot%E4%B8%AD%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">Spring Boot中过滤器（Filter），拦截器（Interceptor）和控制器通知（ControllerAdvice）的区别和使用场景</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Spring Boot中，我们经常会遇到需要对请求和响应进行一些处理的需求，例如验证用户身份，记录日志，处理异常等。为了实现这些功能，Spring Boot提供了三种常用的机制：过滤器（Filter），拦截器（Interceptor）和控制器通知（ControllerAdvice。这三种机制都可以对请求和响应进行拦截和处理，但它们有不同的特点和适用场景。本文将介绍它们的区别和使用方法，并给出一些代码示例。</p>
<h2 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h2><p>过滤器是属于Web服务器的，它可以对任何请求进行拦截和处理，无论是否经过DispatcherServlet分发。过滤器是基于回调函数的，需要实现javax.servlet.Filter接口，并重写doFilter()方法。过滤器可以修改请求和响应对象，甚至可以替换它们。过滤器需要在web.xml中配置，或者使用@WebFilter注解。</p>
<p>过滤器通常用于处理请求内容和视图内容，例如多部分表单和GZIP压缩等。这通常表现在需要将过滤器映射到某些内容类型（例如图片）或者所有请求上。</p>
<h3 id="过滤器的使用方法"><a href="#过滤器的使用方法" class="headerlink" title="过滤器的使用方法"></a>过滤器的使用方法</h3><p>要使用过滤器，我们需要做以下几步：</p>
<ul>
<li>定义一个类，实现Filter接口，并重写doFilter()方法。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 对请求和响应进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter doFilter&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// 继续执行后续的过滤器或者处理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在web.xml中配置过滤器，并指定要拦截的URL模式。例如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>或者使用@WebFilter注解来配置过滤器，并指定要拦截的URL模式。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Spring Boot中，还需要在配置类中添加@ServletComponentScan注解，以启用@WebFilter注解。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">// 启用@WebFilter注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><p>拦截器是属于Spring MVC框架的，它只能对经过DispatcherServlet分发的请求进行拦截和处理。拦截器是基于Java反射机制的，需要实现org.springframework.web.servlet.HandlerInterceptor接口，并重写preHandle(), postHandle()和afterCompletion()方法。拦截器只能对请求和响应对象进行访问或者添加属性，不能修改或者替换它们。拦截器需要在Spring MVC的配置中指定，并指定要拦截的URL模式。</p>
<p>拦截器通常用于处理细粒度的处理器相关的预处理和后处理任务，例如提取公共处理器代码和授权检查等。</p>
<h3 id="拦截器的使用方法"><a href="#拦截器的使用方法" class="headerlink" title="拦截器的使用方法"></a>拦截器的使用方法</h3><p>要使用拦截器，我们需要做以下几步：</p>
<ul>
<li>定义一个类，实现HandlerInterceptor接口，并重写preHandle(), postHandle()和afterCompletion()方法。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在处理器执行之前进行拦截</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true表示继续执行处理器，返回false表示中断执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在处理器执行之后，但在视图渲染之前进行拦截</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在请求处理完成之后，即在视图渲染之后进行拦截</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Spring MVC的配置中添加拦截器，并指定要拦截的URL模式。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 拦截所有请求</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 排除登录请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制器通知（ControllerAdvice）"><a href="#控制器通知（ControllerAdvice）" class="headerlink" title="控制器通知（ControllerAdvice）"></a>控制器通知（ControllerAdvice）</h2><p>控制器通知是属于Spring MVC框架的，它可以对处理器抛出的异常进行统一的处理。控制器通知是基于注解的，需要在类上使用@ControllerAdvice注解，并在方法上使用@ExceptionHandler注解。控制器通知可以对异常对象进行访问或者添加属性，也可以修改或者替换响应对象。控制器通知不需要在配置中指定，只需要在类上使用@ControllerAdvice注解即可。</p>
<p>控制器通知通常用于处理全局的异常情况，例如参数校验异常，业务逻辑异常，系统异常等。</p>
<h3 id="控制器通知的使用方法"><a href="#控制器通知的使用方法" class="headerlink" title="控制器通知的使用方法"></a>控制器通知的使用方法</h3><p>要使用控制器通知，我们需要做以下几步：</p>
<ul>
<li>定义一个类，并使用@ControllerAdvice注解。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类中定义一个或多个方法，并使用@ExceptionHandler注解，并指定要处理的异常类型。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleNullPointerException</span><span class="params">(NullPointerException e)</span> &#123;</span><br><span class="line">    <span class="comment">// 对空指针异常进行处理</span></span><br><span class="line">    System.out.println(<span class="string">&quot;MyControllerAdvice handleNullPointerException&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在处理器中抛出异常，让控制器通知来捕获并处理。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟抛出空指针异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>为了演示过滤器，拦截器和控制器通知的效果，我们可以创建一个简单的Spring Boot应用，并添加以下代码：</p>
<blockquote>
<p>代码地址：<em><a target="_blank" rel="noopener" href="https://github.com/mikezex/InterceptorDemo">https://github.com/mikezex/InterceptorDemo</a></em></p>
</blockquote>
<ul>
<li>过滤器：打印请求和响应的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter doFilter&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Request: &quot;</span> + request);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">&quot;Response: &quot;</span> + response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在启动类中添加配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">// 启用@WebFilter注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorStudyDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(InterceptorStudyDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>拦截器：打印请求和响应的状态码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor preHandle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Request status: &quot;</span> + request.getDispatcherType());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor postHandle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Response status: &quot;</span> + response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ControllerAdvice控制器通知,监听Controller异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// 对所有异常进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyControllerAdvice handleException&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Exception: &quot;</span> + e);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个Controller请求，并且模拟异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试拦截器 Interceptor、过滤器 Filter、控制通知器 ControllerAdvice 的先后顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建测试类，进行模拟调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorStudyDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span> &#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(<span class="string">&quot;/user/1&quot;</span>, String.class);</span><br><span class="line">        System.out.println(response.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回结果为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--MyFilter init--&gt;</span><br><span class="line">&lt;!--MyFilter doFilter--&gt;</span><br><span class="line">&lt;!--Request: org.apache.catalina.connector.RequestFacade@546b670--&gt;</span><br><span class="line">&lt;!--MyInterceptor preHandle--&gt;</span><br><span class="line">&lt;!--Request status: REQUEST--&gt;</span><br><span class="line">&lt;!--无注解请求，逻辑处理--&gt;</span><br><span class="line">&lt;!--MyControllerAdvice handleException--&gt;</span><br><span class="line">&lt;!--Exception: java.lang.RuntimeException: User not found--&gt;</span><br><span class="line">&lt;!--MyInterceptor afterCompletion--&gt;</span><br><span class="line">&lt;!--Response: org.apache.catalina.connector.ResponseFacade@5340a792--&gt;</span><br><span class="line">&lt;!--User not found--&gt;</span><br><span class="line">&lt;!--MyFilter destroy--&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从输出结果可以看出，过滤器，拦截器和控制器通知都对请求和响应进行了拦截和处理，但它们的执行顺序和作用范围不同。过滤器是最先执行的，也是最后执行的，它可以对任何请求和响应进行处理。拦截器是在过滤器之后，控制器通知之前执行的，它只能对经过DispatcherServlet分发的请求和响应进行处理。控制器通知是在拦截器之后，视图渲染之前执行的，它只能对处理器抛出的异常进行处理。我们可以根据不同的需求，选择合适的机制来对请求和响应进行处理。希望本文对你有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/20/Spring-Boot%E4%B8%AD%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" data-id="cllnaeugz0005vki792cih6wu" data-title="Spring Boot中过滤器（Filter），拦截器（Interceptor）和控制器通知（ControllerAdvice）的区别和使用场景" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java多线程怎么玩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%8E%A9/" class="article-date">
  <time class="dt-published" datetime="2023-07-20T07:53:06.000Z" itemprop="datePublished">2023-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%8E%A9/">Java多线程怎么玩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="线程的类与包"><a href="#线程的类与包" class="headerlink" title="线程的类与包"></a>线程的类与包</h2><p>在Java中，有关线程的类和包主要有以下几个：</p>
<ul>
<li><p><code>java.lang.Thread</code>：这是线程的基本类，它提供了创建和管理线程的方法，如<code>start()</code>, <code>run()</code>, <code>sleep()</code>, <code>join()</code>, <code>interrupt()</code>等。</p>
</li>
<li><p><code>java.lang.Runnable</code>：这是一个函数式接口，它定义了一个抽象方法<code>run()</code>，用于在线程中执行任务。任何实现了<code>Runnable</code>接口的类都可以作为线程的目标对象。</p>
</li>
<li><p><code>java.util.concurrent</code>：这是一个并发编程的工具包，它提供了许多高级的线程管理和协调的类和接口，如<code>ExecutorService</code>, <code>Future</code>, <code>Callable</code>, <code>Lock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>等。</p>
</li>
<li><p><code>java.util.concurrent.atomic</code>：这是一个原子操作的工具包，它提供了一些支持无锁并发编程的类，如<code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>等。</p>
</li>
<li><p><code>java.util.concurrent.locks</code>：这是一个锁相关的工具包，它提供了一些比<code>synchronized</code>关键字更灵活和高效的锁机制，如<code>ReentrantLock</code>, <code>ReadWriteLock</code>, <code>Condition</code>等。后续的章节回再总结。</p>
</li>
</ul>
<h2 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承<code>Thread</code>类</h3><blockquote>
<p>继承<code>Thread</code>类：这是最简单的一种方式，只需要定义一个子类，继承自<code>Thread</code>类，并重写其<code>run()</code>方法，然后创建该子类的对象，并调用其<code>start()</code>方法即可启动线程。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><blockquote>
<p>实现<code>Runnable</code>接口：这是一种更推荐的方式，因为它避免了单继承的局限性，并且更符合面向对象的设计原则。只需要定义一个类，实现<code>Runnable</code>接口，并实现其<code>run()</code>方法，然后创建该类的对象，并将其作为参数传递给<code>Thread</code>类的构造器，再调用其<code>start()</code>方法即可启动线程。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现<code>Callable</code>接口</h3><blockquote>
<p>实现<code>Callable</code>接口：这是一种更高级的方式，它允许线程返回一个结果，并且可以抛出异常。只需要定义一个类，实现<code>Callable</code>接口，并实现其泛型方法<code>call()</code>，然后创建该类的对象，并将其作为参数传递给<code>ExecutorService</code>接口的方法，如<code>submit()</code>或者<code>invokeAll()</code>等，再通过返回的<code>Future</code>对象获取线程的结果或者异常。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// do something and return a result</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyCallable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(c);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用匿名内部类或者Lambda表达式：这是一种更简洁和优雅的方式，它可以省去定义额外的类，直接在创建线程时提供任务的逻辑。只需要将一个匿名内部类或者Lambda表达式作为参数传递给<code>Thread</code>类或者<code>ExecutorService</code>接口即可。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using anonymous inner class</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// using lambda expression</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="使用线程池创建"><a href="#使用线程池创建" class="headerlink" title="使用线程池创建"></a>使用线程池创建</h3><blockquote>
<p>线程池是一种管理和复用线程的机制，它可以避免频繁地创建和销毁线程，提高性能和资源利用率。在Java中，有关线程池的类和接口主要有以下几个：</p>
</blockquote>
<ul>
<li><p><code>java.util.concurrent.Executor</code>：这是一个执行任务的接口，它定义了一个抽象方法<code>execute(Runnable command)</code>，用于接收一个<code>Runnable</code>对象作为任务，并在线程池中执行。</p>
</li>
<li><p><code>java.util.concurrent.ExecutorService</code>：这是一个扩展了<code>Executor</code>接口的子接口，它提供了更多的方法，如<code>submit(Callable&lt;T&gt; task)</code>, <code>shutdown()</code>, <code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code>等，用于提交不同类型的任务，并控制线程池的生命周期和结果。</p>
</li>
<li><p><code>java.util.concurrent.Executors</code>：这是一个工具类，它提供了一些静态方法，用于创建不同类型的线程池，如<code>newCachedThreadPool()</code>, <code>newFixedThreadPool(int nThreads)</code>, <code>newSingleThreadExecutor()</code>等。</p>
</li>
<li><p><code>java.util.concurrent.ThreadPoolExecutor</code>：这是一个实现了<code>ExecutorService</code>接口的类，它是线程池的核心类，它提供了一些构造器和方法，用于自定义线程池的参数和行为，如<code>corePoolSize</code>, <code>maximumPoolSize</code>, <code>keepAliveTime</code>, <code>workQueue</code>, <code>threadFactory</code>, <code>rejectedExecutionHandler</code>等。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建固定的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newFixedThreadPool 固定数量线程池 线程是不会被回收的</span></span><br><span class="line">    <span class="comment">// newCachedThreadPool 缓存线程池，线程会被回收</span></span><br><span class="line">    <span class="comment">// newSingleThreadExecutor 单线程池，从队列中获得任务并且顺序执行</span></span><br><span class="line">    <span class="comment">// newScheduledThreadPool 定时任务的线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     int corePoolSize : 核心线程数量，线程池一旦创建好就有的固定线程， 这些线程用于接收并且处理异步任务，如果任务完结，这些线程会处于空闲状态，依然存在。除非设置allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     int maximumPoolSize: 线程池中允许的最大线程数量,如果请求任务的并发超过了corePoolSize。那个么最大的线程数也不会超过maximumPoolSize（弹性伸缩）</span></span><br><span class="line"><span class="comment">     *     long keepAliveTime: 超时时间，当超过corePoolSize的部分线程超时了，则释放</span></span><br><span class="line"><span class="comment">     *     TimeUnit unit, 超时的时间单位</span></span><br><span class="line"><span class="comment">     *     BlockingQueue&lt;Runnable&gt; workQueue: 阻塞队列，任务执行之前，超出的任务会先保存到一个队列中，线程一旦空闲，则从队列中获取新的任务开始执行</span></span><br><span class="line"><span class="comment">     *     ThreadFactory threadFactory: 线程工厂，怎么去创建线程的</span></span><br><span class="line"><span class="comment">     *     RejectedExecutionHandler handler ：驳回与拒绝的策略，队列满了或者队列达到了性能的瓶颈。采取的策略</span></span><br><span class="line"><span class="comment">     *                      AbortPolicy -:新任务进来则直接丢弃（抛异常）</span></span><br><span class="line"><span class="comment">     *                  CallerRunPolicy -:不用线程，直接调用run方法，为了保证任务一个都不丢失。但是可能会出现数据处理积压的情况</span></span><br><span class="line"><span class="comment">     *                  DiscardOlddestPolicy -:丢弃老的任务，使用新的任务</span></span><br><span class="line"><span class="comment">     *                  DiscardPolicy-：丢弃新的任务，不会抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    <span class="number">30</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5000</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>以下是一个使用线程池创建线程的示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a fixed thread pool with 5 threads</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a list of tasks</span></span><br><span class="line">List&lt;Callable&lt;Integer&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    tasks.add(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// do something and return a result</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit the tasks and get the results</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futures = executor.invokeAll(tasks);</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        <span class="comment">// do something with the result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shutdown the thread pool</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%8E%A9/1.png" alt="案例"></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>CompletableFuture</code>是一个实现了<code>Future</code>接口的类，它提供了一种异步编程的方式，可以方便地组合多个线程的结果，处理异常，执行回调等。它有以下几个特点：</p>
<ul>
<li><p>可以通过静态方法<code>supplyAsync()</code>或者<code>runAsync()</code>创建，传入一个<code>Supplier</code>或者<code>Runnable</code>作为任务的逻辑，返回一个<code>CompletableFuture</code>对象。</p>
<blockquote>
<p>supplyAsync() Callable+Thread:异步线程可以获得返回值 但是会阻塞当前线程</p>
</blockquote>
<blockquote>
<p>runAsync() Thread + Runnable:异步线程 但是已无法获得返回值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CompletableFutureTest</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runAsync: Thread + Runnable:异步线程 但是已无法获得返回值</span></span><br><span class="line"><span class="comment">     * supplyAsync: Callable+Thread:异步线程可以获得返回值 但是会阻塞当前线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture =</span><br><span class="line">            CompletableFuture.runAsync(<span class="keyword">new</span> <span class="title class_">RunnableClass_01</span>(),MyThreadPool.executorService);</span><br><span class="line">    </span><br><span class="line">   CompletableFuture&lt;String&gt; completableFuture =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;内部打印:&quot;</span>+uuId);</span><br><span class="line">        <span class="keyword">return</span> uuId;</span><br><span class="line">    &#125;,MyThreadPool.executor);</span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">&quot;外部获取的UUID:&quot;</span>+completableFuture.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过实例方法<code>thenApply()</code>, <code>thenAccept()</code>, <code>thenRun()</code>等，对上一个线程的结果进行转换，消费或者执行，返回一个新的<code>CompletableFuture</code>对象。</p>
<ul>
<li>thenRun()    线程任务执行结束之后执行该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CompletableFutureTestThenRun</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1打印:&quot;</span>+uuId);</span><br><span class="line">        <span class="comment">// return uuId;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;,MyThreadPool.executorService).thenRun(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Then Run打印，执行完任务1之后执行该操作，无参，也没有返回值&quot;</span>);</span><br><span class="line">    &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;进入兜底异常处理类&quot;</span>);</span><br><span class="line">        <span class="comment">// return &quot;1111&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>thenAccept() 线程任务执行结束之后执行该方法，可以接收线程任务返回的结果值，并做处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CompletableFutureTestThenAccept</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1打印:&quot;</span>+uuId);</span><br><span class="line">        <span class="keyword">return</span> uuId;</span><br><span class="line">    &#125;,MyThreadPool.executorService).exceptionally(throwable -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兜底校验获取的的错误信息:&quot;</span>+throwable.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;).thenAccept(o -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Accept中接收上一步返回的参数:&quot;</span>+o);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>thenApply()  线程任务执行结束之后执行该方法，可以接收上一线程任务返回的参数，并且有返回值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CompletableFutureTestThenApply</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1打印:&quot;</span>+uuId);</span><br><span class="line">        <span class="keyword">return</span> uuId;</span><br><span class="line">    &#125;,MyThreadPool.executorService).exceptionally(throwable -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兜底校验获取的的错误信息:&quot;</span>+throwable.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;).thenApply(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Accept中接收上一步返回的参数:&quot;</span>+s);</span><br><span class="line">        <span class="keyword">return</span> s+<span class="string">&quot;:&quot;</span>+LocalDateTime.now();</span><br><span class="line">    &#125;).thenApply(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;_&quot;</span> + <span class="number">66666</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>封装了一些Both相关的方法，<code>runAfterBoth()</code>,<code>runAfterEither()</code>,<code>thenAcceptBoth()</code>,用于处理俩个线程之间的运行逻辑。</p>
</li>
<li><p>可以通过实例方法<code>thenCompose()</code>, <code>thenCombine()</code>, <code>allOf()</code>, <code>anyOf()</code>等，将多个线程的结果进行串行或者并行的组合，返回一个新的<code>CompletableFuture</code>对象。</p>
</li>
<li><p>可以通过实例方法<code>exceptionally()</code>, <code>handle()</code>, <code>whenComplete()</code>等，对线程中发生的异常进行处理或者执行完成后的操作，返回一个新的或者原来的<code>CompletableFuture</code>对象。</p>
<ul>
<li><p>exceptionally 线程异常处理捕获的场景</p>
</li>
<li><p>handle现成结果集处理数据再加工的场景</p>
</li>
<li><p>whenComplete 现成执行完毕</p>
</li>
</ul>
</li>
<li><p>可以通过实例方法<code>join()</code>或者<code>get()</code>获取线程的结果或者异常，</p>
<ul>
<li>区别在于join()不会抛出异常，而get()会。</li>
</ul>
</li>
</ul>
<p>因为场景很多，就不一一例举了。以下是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a CompletableFuture that returns a string</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something and return a string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create another CompletableFuture that returns a string</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something and return a string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// combine the two CompletableFutures and print the result</span></span><br><span class="line">cf1.thenCombine(cf2, (s1, s2) -&gt; s1 + <span class="string">&quot; &quot;</span> + s2).thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%8E%A9/" data-id="cllnaeugy0004vki7793l305m" data-title="Java多线程怎么玩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Git常用命令汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T10:55:13.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天聊一下git,其实IDEA自带的插件已经完全可以满足日常工作的需求，有的时候甚至不需要你自己敲命令就可以实现分支的管理。但是这里还是列举一下平时工作中常用到的一些命令。</p>
<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是一个分布式版本控制系统，它可以帮助你跟踪和管理代码的变化。它最初由Linus Torvalds开发，现在已经成为世界上最流行的版本控制系统之一。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>使用场景</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>创建仓库</td>
<td><code>git init</code></td>
<td>在当前目录下初始化一个新的Git仓库</td>
</tr>
<tr>
<td>克隆仓库</td>
<td><code>git clone [url]</code></td>
<td>克隆一个远程仓库到本地</td>
</tr>
<tr>
<td>添加文件</td>
<td><code>git add [file]</code></td>
<td>将文件添加到暂存区</td>
</tr>
<tr>
<td>提交更改</td>
<td><code>git commit -m [message]</code></td>
<td>将暂存区中的更改提交到本地仓库</td>
</tr>
<tr>
<td>查看状态</td>
<td><code>git status</code></td>
<td>查看当前仓库的状态</td>
</tr>
<tr>
<td>查看历史记录</td>
<td><code>git log</code></td>
<td>查看提交历史记录</td>
</tr>
<tr>
<td>切换分支</td>
<td><code>git checkout [branch]</code></td>
<td>切换到指定分支</td>
</tr>
<tr>
<td>创建分支</td>
<td><code>git branch [name]</code></td>
<td>创建一个新分支</td>
</tr>
<tr>
<td>合并分支</td>
<td><code>git merge [branch]</code></td>
<td>将指定分支合并到当前分支</td>
</tr>
<tr>
<td>更新本地仓库</td>
<td><code>git pull</code></td>
<td>从远程仓库拉取最新更改并合并到本地仓库</td>
</tr>
<tr>
<td>推送本地文件到远程</td>
<td><code>git push </code></td>
<td>将本地仓库中的更改推送到远程仓库</td>
</tr>
</tbody></table>
<h2 id="如何将版本本地版本回退之后，重新推送远程"><a href="#如何将版本本地版本回退之后，重新推送远程" class="headerlink" title="如何将版本本地版本回退之后，重新推送远程"></a>如何将版本本地版本回退之后，重新推送远程</h2><blockquote>
<p>如果您想回退本地版本并将更改推送到远程仓库，可以按照以下步骤操作：</p>
</blockquote>
<ol>
<li>首先，使用<code>git log</code>命令查看提交历史记录，找到您想回退到的版本的哈希值（例如，<code>commit 1a2b3c4d</code>）。</li>
<li>然后，使用<code>git reset</code>命令回退到指定版本。例如，如果您想回退到哈希值为<code>1a2b3c4d</code>的版本，可以使用以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1a2b3c4d</span><br></pre></td></tr></table></figure>

<p>请注意，这将删除您在当前版本中所做的所有更改。如果您想保留这些更改，可以使用<code>--soft</code>选项而不是<code>--hard</code>选项。</p>
<ol start="3">
<li>最后，使用<code>git push</code>命令将更改推送到远程仓库。由于您回退了版本，因此需要使用<code>--force</code>选项强制推送更改。例如，如果您想将更改推送到远程仓库的<code>master</code>分支，可以使用以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，强制推送可能会覆盖远程仓库中其他人所做的更改。因此，在使用<code>--force</code>选项之前，请确保您了解其后果并与团队成员进行协调。</p>
</blockquote>
<p>当然熟悉git命令的同时还要用心的解决代码冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/" data-id="cllnaeugz0006vki75f4h7090" data-title="Git常用命令汇总" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Docker命令汇总、最常用的也就几句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T02:49:08.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/">Docker命令汇总、最常用的也就这几句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker是一个开源的容器虚拟化平台，可以让开发者打包应用和依赖环境到一个轻量级、可移植的容器中，然后发布到任何支持Docker的机器上，实现快速、一致的部署和运行。</p>
<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><p>Docker的常用命令一般分为以下几类：</p>
<ul>
<li>Docker环境信息：查看Docker的版本、状态、配置等信息。</li>
<li>Docker镜像管理：搜索、下载、创建、删除、修改Docker镜像。</li>
<li>Docker容器管理：创建、启动、停止、重启、删除、进入Docker容器，以及查看容器的日志、状态、信息等。</li>
<li>Docker其他命令：包括网络管理、数据卷管理、仓库管理等。</li>
</ul>
<p>下面我们来详细介绍每类命令的语法和使用场景。</p>
<h3 id="Docker环境信息"><a href="#Docker环境信息" class="headerlink" title="Docker环境信息"></a>Docker环境信息</h3><ul>
<li><code>docker version</code>：查看Docker的客户端和服务端的版本信息。</li>
<li><code>docker info</code>：查看Docker的系统信息，包括镜像和容器的数量，存储和网络的驱动，运行模式等。</li>
<li><code>docker --help</code>：查看Docker的帮助信息，包括所有命令的简要说明和选项。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在安装或更新Docker后，可以使用<code>docker version</code>和<code>docker info</code>来检查Docker是否正常运行，以及了解Docker的基本配置。</li>
<li>在使用Docker时，可以使用<code>docker --help</code>来查看某个命令的用法和参数。</li>
</ul>
<h3 id="Docker镜像管理"><a href="#Docker镜像管理" class="headerlink" title="Docker镜像管理"></a>Docker镜像管理</h3><ul>
<li><code>docker images</code>：查看本地主机上的所有镜像，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker search</code>：从Docker Hub或其他仓库中搜索镜像，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker pull</code>：从Docker Hub或其他仓库中下载镜像到本地主机，可以指定镜像的名称和标签。</li>
<li><code>docker rmi</code>：删除本地主机上的一个或多个镜像，可以指定镜像的ID或名称和标签。</li>
<li><code>docker tag</code>：给本地主机上的一个镜像添加一个新的标签，可以指定源镜像和目标镜像的名称和标签。</li>
<li><code>docker build</code>：根据指定的Dockerfile文件来构建一个新的镜像，可以指定选项和上下文路径。</li>
<li><code>docker history</code>：查看一个镜像的创建历史，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker save</code>：将一个或多个镜像保存为一个tar归档文件，可以指定输出文件名或标准输出。</li>
<li><code>docker load</code>：从一个tar归档文件或标准输入中加载一个或多个镜像到本地主机。</li>
<li><code>docker import</code>：从一个tar归档文件或标准输入中导入一个容器快照为一个新的镜像，可以指定选项和目标镜像的名称和标签。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在使用Docker时，需要经常操作镜像，比如下载常用的基础镜像，删除不需要的镜像，创建自定义的镜像等。这些操作都需要用到上面介绍的命令。</li>
<li>在进行镜像备份或迁移时，需要用到<code>docker save</code>和<code>docker load</code>命令来保存和加载镜像文件。</li>
<li>在进行容器快照时，需要用到<code>docker import</code>命令来导入容器状态为一个新的镜像。</li>
</ul>
<h3 id="Docker容器管理"><a href="#Docker容器管理" class="headerlink" title="Docker容器管理"></a>Docker容器管理</h3><ul>
<li><code>docker run</code>：创建并启动一个新的容器，可以指定镜像、命令、参数、选项等。</li>
<li><code>docker ps</code>：查看当前运行的所有容器，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker start</code>：启动一个或多个已经创建的容器，可以指定容器的ID或名称。</li>
<li><code>docker stop</code>：停止一个或多个正在运行的容器，可以指定容器的ID或名称。</li>
<li><code>docker restart</code>：重启一个或多个容器，可以指定容器的ID或名称。</li>
<li><code>docker kill</code>：强制停止一个或多个正在运行的容器，可以指定容器的ID或名称。</li>
<li><code>docker rm</code>：删除一个或多个已经停止的容器，可以指定容器的ID或名称。</li>
<li><code>docker pause</code>：暂停一个或多个容器中的所有进程，可以指定容器的ID或名称。</li>
<li><code>docker unpause</code>：恢复一个或多个容器中的所有进程，可以指定容器的ID或名称。</li>
<li><code>docker create</code>：创建一个新的容器但不启动它，可以指定镜像、命令、参数、选项等。</li>
<li><code>docker exec</code>：在一个运行的容器中执行一个命令，可以指定选项和容器的ID或名称。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果想进入一个容器中，可以先执行docker ps 获取容器的ID或者名称</span></span><br><span class="line"><span class="comment"># docker exec -it 7963547123c00 bash 进入容器中</span></span><br><span class="line"><span class="comment"># 退出容器可以使用exit命令 或者ctrl+D</span></span><br></pre></td></tr></table></figure></li>
<li><code>docker logs</code>：查看一个容器的日志，可以指定选项和容器的ID或名称。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器运行日志</span></span><br><span class="line">docker logs -f canal</span><br></pre></td></tr></table></figure></li>
<li><code>docker inspect</code>：查看一个容器的详细信息，可以指定选项和格式化输出结果，可以指定容器的ID或名称。</li>
<li><code>docker top</code>：查看一个容器中运行的进程信息，可以指定选项和容器的ID或名称。</li>
<li><code>docker attach</code>：附加到一个运行的容器上，可以查看和操作标准输入输出流，可以指定容器的ID或名称。</li>
<li><code>docker events</code>：查看Docker服务器上发生的实时事件，可以指定过滤条件和时间范围。</li>
<li><code>docker wait</code>：阻塞直到一个或多个容器停止，然后打印出它们的退出代码，可以指定容器的ID或名称。</li>
<li><code>docker export</code>：将一个容器的文件系统导出为一个tar归档文件，可以指定输出文件名或标准输出，可以指定容器的ID或名称。</li>
<li><code>docker port</code>：查看一个指定的映射到私有端口上的公共端口，可以指定容器的ID或名称。</li>
<li><code>docker cp</code>: 将电脑中的文件复制到docker容器中可以使用此命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker cp 文件 容器名:/容器路径</span></span><br><span class="line"> docker <span class="built_in">cp</span> abc.xml rabbitmq:/plugins</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用场景：</p>
<ul>
<li>在使用Docker时，需要经常操作容器，比如创建并启动应用程序所需的环境，停止和删除不需要的环境等。这些操作都需要用到上面介绍的命令。</li>
<li>在进行容器监控和调试时，需要用到<code>docker logs</code>、<code>docker inspect</code>、<code>docker top</code>、<code>docker events</code>等命令来查看容器的日志、状态、进程、事件等信息。</li>
<li>在进行容器交互时，需要用到<code>docker exec</code>、<code>docker attach</code>等命令来在运行中的容器中执行命令或操作输入输出流。</li>
<li>在进行容器备份时，需要用到<code>docker export</code>命令来导出容器文件系统为一个tar归档文件。</li>
</ul>
<h3 id="Docker其他命令"><a href="#Docker其他命令" class="headerlink" title="Docker其他命令"></a>Docker其他命令</h3><p>除了上面介绍的三类命令外，Docker还提供了一些其他类型的命令，比如：</p>
<ul>
<li>网络管理：包括创建、删除、列出、检查、连接、断开Docker网络等命令。例如：<ul>
<li><code>docker network create</code>: 创建一个新的网络</li>
<li><code>docker network ls</code>: 列出所有网络</li>
<li><code>docker network inspect</code>: 查看网络详细信息</li>
<li><code>docker network rm</code>: 删除网络</li>
<li><code>docker network connect</code>: 连接一个网络到一个运行中的容器</li>
<li><code>docker network disconnect</code>: 从一个网络断开一个运行中的容器</li>
</ul>
</li>
<li>数据卷管理：包括创建、删除</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/" data-id="cllnaeugr0000vki70e6wea65" data-title="Docker命令汇总、最常用的也就这几句" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-试玩Canal，0入侵实现缓存同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2023-07-07T07:55:37.000Z" itemprop="datePublished">2023-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/">试玩Canal，零侵入实现缓存同步</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是canal"><a href="#什么是canal" class="headerlink" title="什么是canal"></a>什么是canal</h2><p>canal是一个基于MySQL二进制日志的高性能数据同步系统，可以将MySQL的增量数据订阅和消费，实现MySQL数据的实时同步。canal广泛用于阿里巴巴集团（包括 taobao.com ），以提供可靠的低延迟增量数据管道。canal的项目地址是：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="canal的工作原理"><a href="#canal的工作原理" class="headerlink" title="canal的工作原理"></a>canal的工作原理</h2><p>canal的工作原理是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。</p>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image.png" alt="Alt text"></p>
<h2 id="canal的优缺点"><a href="#canal的优缺点" class="headerlink" title="canal的优缺点"></a>canal的优缺点</h2><p>canal的优点是：</p>
<ul>
<li>部署简单，易于运维，适用于中小规模MySQL数据同步。</li>
<li>支持多种存储目的地，比如MySQL，Kafka，Elastic Search等等。</li>
<li>支持多种数据处理场景，比如数据库镜像、数据库实时备份、索引构建和实时维护、业务cache刷新、带业务逻辑的增量数据处理等等。</li>
<li>对代码的入侵性为0，不需要改动已有业务代码就可以实现数据备份</li>
</ul>
<p>canal的缺点是：</p>
<ul>
<li>同步的是增量数据，不会同步之前的存量数据。</li>
<li>单docker实例只能运行一个instance，如果需要运行多instance时，需要自行制作一份docker镜像。</li>
</ul>
<h2 id="如何快速在docker上安装部署一个canal"><a href="#如何快速在docker上安装部署一个canal" class="headerlink" title="如何快速在docker上安装部署一个canal"></a>如何快速在docker上安装部署一个canal</h2><p>在docker上安装部署一个canal的步骤如下：</p>
<ol>
<li><p>首先有一个MySQL服务器，并且开启binlog功能（开启binlog之后会牺牲mysql的一点点性能，总体来说利大于弊），并且配置binlog-format为ROW模式,在mysql的安装目录下找到my.cnf，添加配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin <span class="comment"># 开启 binlog</span></span><br><span class="line">binlog-format=ROW <span class="comment"># 选择 ROW 模式</span></span><br><span class="line">server_id=1 <span class="comment"># 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId </span></span><br><span class="line">binlog-do-db=test-db <span class="comment">#指定开启binlog的数据库名称，可以使多个。不设置默认开启全部</span></span><br></pre></td></tr></table></figure>
<p>修改后，需要重启mysql服务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重启后可以根据 查看bin_log的开启状态，以及保存路径</span></span><br><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-1.png" alt="Alt text"></p>
</li>
<li><p>在MySQL中创建一个用户，并授权SELECT, REPLICATION SLAVE, REPLICATION CLIENT权限。官网中的脚本可以直接执行,创建一个canal用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;canal&#x27;</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; ;</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="MySQL-binlog日志三种模式"><a href="#MySQL-binlog日志三种模式" class="headerlink" title="MySQL binlog日志三种模式"></a>MySQL binlog日志三种模式</h1><blockquote>
<p>这里插播一下STATEMENT，ROW，MIXED三种模式的区别，面试可能会涉及<br>MySQL binlog日志是用来记录MySQL数据库内部增删改等对数据库有更新内容的记录，主要用于数据库的主从复制和增量恢复。binlog日志有三种格式：STATEMENT，ROW，MIXED。这三种格式各有优缺点，根据不同的业务场景选择合适的格式。</p>
</blockquote>
<h2 id="binlog日志三种模式的优缺点"><a href="#binlog日志三种模式的优缺点" class="headerlink" title="binlog日志三种模式的优缺点"></a>binlog日志三种模式的优缺点</h2><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STATEMENT</td>
<td align="left">- binlog文件较小，节约磁盘IO，提高性能 <br> - binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况 <br> - binlog可以用于实时的还原，而不仅仅用于复制 <br> - 主从版本可以不一样，从服务器版本可以比主服务器版本高</td>
<td align="left">- 不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候 <br> - 调用具有不确定因素的UDF时复制也可能出问题 <br> - 使用以下函数的语句也无法被复制：LOAD_FILE ()，UUID ()，USER ()，FOUND_ROWS ()，SYSDATE ()等 <br> - INSERT … SELECT 会产生比 RBR 更多的行级锁 <br> - 复制需要进行全表扫描 (WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁 <br> - 对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句 <br> - 对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响 <br> - 存储函数 (不是存储过程)在被调用的同时也会执行一次 NOW () 函数，这个可以说是坏事也可能是好事 <br> - 确定了的 UDF 也需要在从服务器上执行 <br> - 数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错 <br> - 执行复杂语句如果出错的话，会消耗更多资源</td>
</tr>
<tr>
<td align="center">ROW</td>
<td align="left">- 任何情况都可以被复制，这对复制来说是最安全可靠的 <br> - 和其他大多数数据库系统的复制技术一样 <br> - 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多 <br> - 复制以下几种语句时的行锁更少：INSERT … SELECT ，包含 AUTO_INCREMENT 字段的 INSERT ，没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句 <br> - 执行 INSERT，UPDATE，DELETE 语句时锁更少 <br> - 从服务器上采用多线程来执行复制成为可能</td>
<td align="left">- binlog 大了很多 <br> - 主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 <br> - UDF 产生的大 BLOB 值会导致复制变慢 <br> - 无法从 binlog 中看到都复制了写什么语句 <br> - 当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生</td>
</tr>
<tr>
<td align="center">MIXED</td>
<td align="left">- 以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式 <br> - 兼顾了binlog文件大小和复制安全性</td>
<td align="left">- 可能会导致主从服务器的数据不一致，因为不同的模式下，锁的粒度不一样</td>
</tr>
</tbody></table>
<h3 id="为什么配置binlog-format为ROW模式"><a href="#为什么配置binlog-format为ROW模式" class="headerlink" title="为什么配置binlog-format为ROW模式"></a>为什么配置binlog-format为ROW模式</h3><ul>
<li>canal在配置时需要将binlog-format设置为ROW模式，是因为canal需要解析MySQL的二进制日志，获取每一行数据的变化细节，以便实现数据的实时同步。</li>
<li>如果设置为其他两种模式，即STATEMENT或MIXED，会有以下问题：<ul>
<li>STATEMENT模式下，binlog只会记录和传输SQL语句，而不包含具体数据，canal无法保存和同步数据。</li>
<li>STATEMENT模式下，也会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>MIXED模式下，MySQL会根据执行的SQL语句选择日志保存方式，可能会导致主从服务器的数据不一致，因为不同的模式下，锁的粒度不一样。</li>
</ul>
</li>
</ul>
<h2 id="在Docker中快速搭建canal"><a href="#在Docker中快速搭建canal" class="headerlink" title="在Docker中快速搭建canal"></a>在Docker中快速搭建canal</h2><p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-2.png" alt="Alt text"><br>3. 从docker hub获取最新的canal镜像，并拉取到本地。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker pull canal/canal-server:v1.1.6</span><br><span class="line"><span class="comment"># 运行canal</span></span><br><span class="line">docker run -p 11111:11111 \</span><br><span class="line">--name canal \</span><br><span class="line">-e canal.destinations=zexx \</span><br><span class="line">-e canal.instance.mysql.slaveId=20230710 \</span><br><span class="line">-e canal.instance.master.address=192.168.1.6:3306 \</span><br><span class="line">-e canal.instance.dbUsername=canal \</span><br><span class="line">-e canal.instance.dbPassword=canal \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.filter.regex=zexx-hire-dev.data_dictionary \</span><br><span class="line">--restart=always \</span><br><span class="line">-d canal/canal-server:v1.1.6</span><br><span class="line"></span><br><span class="line"><span class="comment">#11111:11111：端口映射</span></span><br><span class="line"><span class="comment">#–name canal：容器名称</span></span><br><span class="line"><span class="comment">#–restart=always：自动重启</span></span><br><span class="line"><span class="comment">#canal.destinations：集群名称，给集群取一个名字</span></span><br><span class="line"><span class="comment">#canal.instance.mysql.slaveId：区别master的id，保证唯一</span></span><br><span class="line"><span class="comment">#canal.instance.master.address：mysql主数据库地址</span></span><br><span class="line"><span class="comment">#canal.instance.dbUsername/dbPassword：用户名和密码，也#就是之前上一节课所创建的用户以及授权，如果设置root用户其实也行。</span></span><br><span class="line"><span class="comment">#canal.instance.connectionCharset：字符集</span></span><br><span class="line"><span class="comment">#canal.instance.filter.regex：监听数据库数据表的表达式，多个可用逗号,连接</span></span><br><span class="line"><span class="comment">#以上环境变量如果不设置，也可以，但是需要在canal内部去修改canal-server配置也是OK的。</span></span><br></pre></td></tr></table></figure>
<p>启动完成之后，需要进入容器内</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it canal bash</span><br><span class="line"><span class="built_in">cd</span> /home/admin/canal-server/logs/xxx </span><br><span class="line"><span class="comment">## 下查看启动日志，验证是否启动成功。如果报错应该是链接数据库失败（可能会有mysql服务器地址不对，mysql用户密码策略、过期时间错误导致）</span></span><br></pre></td></tr></table></figure>

<h2 id="在springboot中集成"><a href="#在springboot中集成" class="headerlink" title="在springboot中集成"></a>在springboot中集成</h2><blockquote>
<p>因为canal是基于数据库层的解析，可以单独创建一个模块，与原有业务隔离完成，数据的操作。可以解决缓存同步、或者数据的问题。比如利用canal客户端更新缓存，或者同步数据，发送MQ消息等。<br>4. pom.xml文件添加依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.xml中添加canal相关配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">zexx</span> <span class="comment"># 空间名</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.6</span><span class="string">:11111</span> <span class="comment"># canal服务端地址</span></span><br><span class="line">  <span class="attr">user-name:</span> <span class="string">canal</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">canal</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">top.javatool.canal.client:</span> <span class="string">warn</span> <span class="comment"># 屏蔽监听日志的输入</span></span><br></pre></td></tr></table></figure>

<p>然后再编写监听类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zexx.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zexx.model.DataDictionary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *定义canal的监听类，用于接收canalserver同步的binlog信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CanalTable(&quot;data_dictionary&quot;)</span> <span class="comment">// 监听的表明</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDictSyncHelper</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;DataDictionary&gt; &#123;  <span class="comment">// 指定表的实体类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DataDictionary before, DataDictionary after)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改操作&quot;</span>);</span><br><span class="line">        System.out.println(before);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后&quot;</span>);</span><br><span class="line">        System.out.println(after);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataDictionary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(DataDictionary dataDictionary)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除操作&quot;</span>);</span><br><span class="line">        System.out.println(dataDictionary);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataDictionary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DataDictionary dataDictionary)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新增操作&quot;</span>);</span><br><span class="line">        System.out.println(dataDictionary);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新服务，修改数据库中对应的表，可以看到后台会打印相关日志。<br><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-3.png" alt="Alt text"><br>但是可以看到，很多字段的值都为空，这个是因为绑定的实体类的名称为驼峰命名，canal在解析时，无法对应字段。所以为空。需要重新绑定一个实体类即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zexx.model.co;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 数据字典表 CO 用于接收canal的同步消息</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zxwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-04-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDictionaryCO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String type_code;</span><br><span class="line">    <span class="keyword">private</span> String type_name;</span><br><span class="line">    <span class="keyword">private</span> String item_key;</span><br><span class="line">    <span class="keyword">private</span> String item_value;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新启动，解析成功</p>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-4.png" alt="Alt text"></p>
<p>集成Redis或者ES、MQ之后，可以在对应的方法中进行业务操作</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">canal官方</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">canal-client官方</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langtianya/p/5504774.html">mysql中binlog_format模式与配置详解 - jack_ou - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/youzhibing/p/13131485.html">MySQL 日志之 binlog 格式 → 关于 MySQL 默认隔离级别的一些思考 - 如.若 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/67809.html">如何设置MySQL数据库备份的binlog_format - 阿里云</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96628405">史上最全的分布式数据同步中间间canal 之入门篇 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/440315272">Canal——Mysql的binlog最好的解决方案 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjerryj/article/details/77152226">使用 Binlog 和 Canal 从 MySQL 抽取数据 - CSDN博客</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/" data-id="cllnaeuh2000avki7esdu4go9" data-title="试玩Canal，零侵入实现缓存同步" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" rel="tag">数据备份</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-高并发缓存三问-穿透、击穿、雪崩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" class="article-date">
  <time class="dt-published" datetime="2023-07-07T02:11:45.000Z" itemprop="datePublished">2023-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/">高并发缓存三问-穿透、击穿、雪崩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天聊一下面试的经典问题，缓存穿透，缓存击穿与缓存雪崩。</p>
<h1 id="缓存穿透、缓存击穿、缓存雪崩的总结"><a href="#缓存穿透、缓存击穿、缓存雪崩的总结" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩的总结"></a>缓存穿透、缓存击穿、缓存雪崩的总结</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">定义</th>
<th align="center">发生场景</th>
<th align="center">避免的手段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">缓存穿透</td>
<td align="center">请求的key在缓存和数据库中都不存在，导致请求直接打在数据库上</td>
<td align="center">有大量不存在的key被请求，可能是黑客攻击</td>
<td align="center">使用布隆过滤器或者把无效的key存进缓存</td>
</tr>
<tr>
<td align="center">缓存击穿</td>
<td align="center">请求的key是一个热点key，当这个key失效时，有大量并发请求打在数据库上</td>
<td align="center">热点key过期或者缓存重启</td>
<td align="center">对热点key设置永不过期或者使用互斥锁</td>
</tr>
<tr>
<td align="center">缓存雪崩</td>
<td align="center">大量的key在同一时间失效，导致大量请求打在数据库上</td>
<td align="center">缓存宕机或者设置了相同的过期时间</td>
<td align="center">在原有的失效时间上加上一个随机值，使用熔断机制，提高数据库和缓存的容灾能力</td>
</tr>
</tbody></table>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>大量Redis与数据库中匹配不到的key进行请求。导致数据库压力过大，打死。</p>
</blockquote>
<p><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="Alt text"></p>
<h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><blockquote>
<p>方案一：进行添加布隆过滤器,布隆过滤器会将匹配不到的key直接返回。因为布隆过滤器的存储和判断机制，对判断某一个key一定存在有一定的误判率，无法做到百分之百的精准匹配。所以需要根据场景使用。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="Alt text"></p>
</blockquote>
<blockquote>
<p>方案二，key第一次请求时，如果Redis匹配失败，去查询数据库返回null.这将这个空对象进行Redis保存。但是要设置一定的失效时间。</p>
</blockquote>
<h3 id="布隆过滤器机制"><a href="#布隆过滤器机制" class="headerlink" title="布隆过滤器机制"></a>布隆过滤器机制</h3><blockquote>
<p>布隆过滤器是一个由0和1组成二进制数组，所以他不会占用太多内存，就可以实现数据的过滤。</p>
</blockquote>
<ul>
<li>请求中的key会根据hash算法，在二进制数组中进行匹配。比如每一个subCat都是根据三个位置判断是否有效的，如果三个点都是1则表示存在。</li>
<li>但是匹配时，会有数据相交的地方。比如说下图的第三个节点，就是subCat1与subCat2相同的位置。</li>
<li>此时有一个subCat虽然他的key是不存在的。但是根据hash算法解析后，他匹配的数组位置恰好都是1.则布隆过滤器会认为这个key是存在的。则出现了误判。这个误判只对判断一个key是否存在时会产生。</li>
</ul>
<p><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image.png" alt="Alt text"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<p>一个热点的key,在一个高并发的场景下。进行请求，此时Redis中的缓存刚好失效，或者还未生成。导致该场景下的所有请求都绕过了缓存直接请求数据库。导致数据库压力过大直接打死。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image2.png" alt="Alt text"></p>
</blockquote>
<h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><ul>
<li>单线程 setnx<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image-1.png" alt="Alt text"><blockquote>
<p>Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值.存在时设置值会失败。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>因为Redis在接收请求时是单线程的。用户所有的请求都需要排队访问Redis。第一个请求进来时，先判断key是否存在，如果不存在，则setnx一个默认的值，然后请求数据库，然后将返回的数据更新Redis中的数据。此时后续的请求也可以先进行setnx，如果失败，就先等待，一直等到Redis中的数据重新更新成功之后，再放行。这样无论并发场景有多高，访问数据库的次数只有一次。</p>
</blockquote>
<ul>
<li><p>多线程 定期检查。使用一个线程，定时检查数据库中的数据是否在Redis存在。如果没有则进行Redis初始数据。次方法只能针对已知的热点key。</p>
</li>
<li><p>缓存永不过期 </p>
</li>
<li><p>缓存预热</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大量的key在同一时间失效，导致大量请求打在数据库上。导致数据库崩溃。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image-3.png" alt="Alt text"></p>
<h3 id="预防措施-2"><a href="#预防措施-2" class="headerlink" title="预防措施"></a>预防措施</h3><ul>
<li><p>添加失效时间时，增加随机数。这样可以避免同一时间Redis出现大量缓存数据同时失效。</p>
</li>
<li><p>将数据设置为永不过期</p>
</li>
<li><p>多缓存结合</p>
</li>
<li><p>使用熔断机制，提高数据库和缓存的容灾能力</p>
</li>
</ul>
<p>: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346651831">参考-什么是缓存雪崩、缓存击穿、缓存穿透？ - 知乎</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" data-id="cllnaeuh3000dvki72g3t8ule" data-title="高并发缓存三问-穿透、击穿、雪崩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CodeWhisperer自动编程的插件试玩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/" class="article-date">
  <time class="dt-published" datetime="2023-07-06T08:00:57.000Z" itemprop="datePublished">2023-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/">CodeWhisperer自动编程的插件试玩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>程序员实现面向注释编程不是梦</p>
<h1 id="Copilot-vs-CodeWhisperer"><a href="#Copilot-vs-CodeWhisperer" class="headerlink" title="Copilot vs CodeWhisperer"></a>Copilot vs CodeWhisperer</h1><p>Copilot和CodeWhisperer都是基于AI的编程辅助工具，它们可以根据开发者的注释或输入，自动提供代码建议。它们有很多相似之处，但也有一些不同之处，这些不同之处可能会影响你选择使用哪一个工具。下面是一个简单的对比表格，列举了它们的一些主要特点和区别。</p>
<table>
<thead>
<tr>
<th>Copilot</th>
<th>CodeWhisperer</th>
</tr>
</thead>
<tbody><tr>
<td>由GitHub（属于微软）开发，于2021年6月发布测试版，2022年6月正式上线</td>
<td>由亚马逊开发，于2022年6月发布测试版</td>
</tr>
<tr>
<td>基于OpenAI Codex模型，该模型是一个大规模的神经网络，可以生成自然语言和代码</td>
<td>基于亚马逊内部的AI模型，该模型的细节尚未公开</td>
</tr>
<tr>
<td>使用公开的源代码库进行训练，包括GitHub上的数十亿行代码</td>
<td>使用公开和私有的源代码库进行训练，包括亚马逊内部的代码</td>
</tr>
<tr>
<td>支持多种编程语言和框架，目前优化了Python, JavaScript, TypeScript, Ruby, Go, C#, C++等语言</td>
<td>Python、Java、JavaScript、TypeScript、C#、Rust、Go、Ruby、Scala、Kotlin、PHP、C、C++、Shell 脚本编写、SQL。</td>
</tr>
<tr>
<td>支持多种IDE，如Visual Studio, Neovim, VS Code, JetBrains等，也可以在网页上使用</td>
<td>目前，仅在适用于 Python、Java 和 JavaScript 的 VS Code 和 JetBrains IDE 中支持代码安全扫描。</td>
</tr>
<tr>
<td>收费10美元&#x2F;月或100美元&#x2F;年，学生和开源项目贡献者可免费使用</td>
<td>个人免费使用，企业与专业版许付费</td>
</tr>
</tbody></table>
<p>总的来说，Copilot是一个更通用的AI编程辅助工具，而CodeWhisperer是一个更专注于AWS平台的工具。你可以根据你的需求和喜好来选择使用哪一个工具。</p>
<h1 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h1><p>Copilot 可以免费试用30天，但是需要绑定信用卡，想想还是算了。可以用，但是没必要。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/features/copilot">https://github.com/features/copilot</a></p>
</blockquote>
<h1 id="CodeWhisperer"><a href="#CodeWhisperer" class="headerlink" title="CodeWhisperer"></a>CodeWhisperer</h1><p>这个目前是免费的，注册一下玩玩。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/codewhisperer/resources/#Getting_started">https://aws.amazon.com/cn/codewhisperer/resources/#Getting_started</a></p>
</blockquote>
<p>在IDEA插件市场搜索，aws。然后选择AWS Toolkit进行安装<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image.png" alt="Alt text"><br>安装完成之后，侧边会显示aws图标。然后会提示你进行登录<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-2.png" alt="Alt text"><br>选择复制编码登录，然后粘贴复制的编码，创建账号<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-3.png" alt="Alt text"><br>这里会有一个邮箱的验证码认证，验证成功之后，可以重新打开IDEA窗口，然后就可以启动CodeWhisperer了<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-4.png" alt="Alt text"><br>使用了一下，感觉有些卡顿。人机交互的感觉不是很好。AI不是很懂我的样子。可以实现一些简单的日常的算法。能提高一些开发效率。多多少少可以挽救几根头发。对于写代码不喜欢加注释的童鞋，是一个好的工具</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/" data-id="cllnaeugv0001vki7cszy88gn" data-title="CodeWhisperer自动编程的插件试玩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" rel="tag">数据备份</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">开发工具</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" style="font-size: 10px;">数据备份</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/23/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/">SpringBoot集成RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2023/07/20/Spring-Boot%E4%B8%AD%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">Spring Boot中过滤器（Filter），拦截器（Interceptor）和控制器通知（ControllerAdvice）的区别和使用场景</a>
          </li>
        
          <li>
            <a href="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%8E%A9/">Java多线程怎么玩</a>
          </li>
        
          <li>
            <a href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a>
          </li>
        
          <li>
            <a href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/">Docker命令汇总、最常用的也就这几句</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 zex<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>