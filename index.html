<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>日之呼吸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录生活">
<meta property="og:type" content="website">
<meta property="og:title" content="日之呼吸">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="日之呼吸">
<meta property="og:description" content="记录生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zex">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="日之呼吸" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">日之呼吸</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Git常用命令汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T10:55:13.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天聊一下git,其实IDEA自带的插件已经完全可以满足日常工作的需求，有的时候甚至不需要你自己敲命令就可以实现分支的管理。但是这里还是列举一下平时工作中常用到的一些命令。</p>
<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是一个分布式版本控制系统，它可以帮助你跟踪和管理代码的变化。它最初由Linus Torvalds开发，现在已经成为世界上最流行的版本控制系统之一。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>使用场景</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>创建仓库</td>
<td><code>git init</code></td>
<td>在当前目录下初始化一个新的Git仓库</td>
</tr>
<tr>
<td>克隆仓库</td>
<td><code>git clone [url]</code></td>
<td>克隆一个远程仓库到本地</td>
</tr>
<tr>
<td>添加文件</td>
<td><code>git add [file]</code></td>
<td>将文件添加到暂存区</td>
</tr>
<tr>
<td>提交更改</td>
<td><code>git commit -m [message]</code></td>
<td>将暂存区中的更改提交到本地仓库</td>
</tr>
<tr>
<td>查看状态</td>
<td><code>git status</code></td>
<td>查看当前仓库的状态</td>
</tr>
<tr>
<td>查看历史记录</td>
<td><code>git log</code></td>
<td>查看提交历史记录</td>
</tr>
<tr>
<td>切换分支</td>
<td><code>git checkout [branch]</code></td>
<td>切换到指定分支</td>
</tr>
<tr>
<td>创建分支</td>
<td><code>git branch [name]</code></td>
<td>创建一个新分支</td>
</tr>
<tr>
<td>合并分支</td>
<td><code>git merge [branch]</code></td>
<td>将指定分支合并到当前分支</td>
</tr>
<tr>
<td>更新本地仓库</td>
<td><code>git pull</code></td>
<td>从远程仓库拉取最新更改并合并到本地仓库</td>
</tr>
<tr>
<td>推送本地文件到远程</td>
<td><code>git push </code></td>
<td>将本地仓库中的更改推送到远程仓库</td>
</tr>
</tbody></table>
<h2 id="如何将版本本地版本回退之后，重新推送远程"><a href="#如何将版本本地版本回退之后，重新推送远程" class="headerlink" title="如何将版本本地版本回退之后，重新推送远程"></a>如何将版本本地版本回退之后，重新推送远程</h2><blockquote>
<p>如果您想回退本地版本并将更改推送到远程仓库，可以按照以下步骤操作：</p>
</blockquote>
<ol>
<li>首先，使用<code>git log</code>命令查看提交历史记录，找到您想回退到的版本的哈希值（例如，<code>commit 1a2b3c4d</code>）。</li>
<li>然后，使用<code>git reset</code>命令回退到指定版本。例如，如果您想回退到哈希值为<code>1a2b3c4d</code>的版本，可以使用以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1a2b3c4d</span><br></pre></td></tr></table></figure>

<p>请注意，这将删除您在当前版本中所做的所有更改。如果您想保留这些更改，可以使用<code>--soft</code>选项而不是<code>--hard</code>选项。</p>
<ol start="3">
<li>最后，使用<code>git push</code>命令将更改推送到远程仓库。由于您回退了版本，因此需要使用<code>--force</code>选项强制推送更改。例如，如果您想将更改推送到远程仓库的<code>master</code>分支，可以使用以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，强制推送可能会覆盖远程仓库中其他人所做的更改。因此，在使用<code>--force</code>选项之前，请确保您了解其后果并与团队成员进行协调。</p>
</blockquote>
<p>当然熟悉git命令的同时还要用心的解决代码冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/" data-id="cljwriart0003fgi74xqr3vyv" data-title="Git常用命令汇总" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Docker命令汇总、最常用的也就几句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2023-07-10T02:49:08.000Z" itemprop="datePublished">2023-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/">Docker命令汇总、最常用的也就这几句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docker的常用命令与使用场景"><a href="#Docker的常用命令与使用场景" class="headerlink" title="Docker的常用命令与使用场景"></a>Docker的常用命令与使用场景</h1><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker是一个开源的容器虚拟化平台，可以让开发者打包应用和依赖环境到一个轻量级、可移植的容器中，然后发布到任何支持Docker的机器上，实现快速、一致的部署和运行。</p>
<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><p>Docker的常用命令一般分为以下几类：</p>
<ul>
<li>Docker环境信息：查看Docker的版本、状态、配置等信息。</li>
<li>Docker镜像管理：搜索、下载、创建、删除、修改Docker镜像。</li>
<li>Docker容器管理：创建、启动、停止、重启、删除、进入Docker容器，以及查看容器的日志、状态、信息等。</li>
<li>Docker其他命令：包括网络管理、数据卷管理、仓库管理等。</li>
</ul>
<p>下面我们来详细介绍每类命令的语法和使用场景。</p>
<h3 id="Docker环境信息"><a href="#Docker环境信息" class="headerlink" title="Docker环境信息"></a>Docker环境信息</h3><ul>
<li><code>docker version</code>：查看Docker的客户端和服务端的版本信息。</li>
<li><code>docker info</code>：查看Docker的系统信息，包括镜像和容器的数量，存储和网络的驱动，运行模式等。</li>
<li><code>docker --help</code>：查看Docker的帮助信息，包括所有命令的简要说明和选项。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在安装或更新Docker后，可以使用<code>docker version</code>和<code>docker info</code>来检查Docker是否正常运行，以及了解Docker的基本配置。</li>
<li>在使用Docker时，可以使用<code>docker --help</code>来查看某个命令的用法和参数。</li>
</ul>
<h3 id="Docker镜像管理"><a href="#Docker镜像管理" class="headerlink" title="Docker镜像管理"></a>Docker镜像管理</h3><ul>
<li><code>docker images</code>：查看本地主机上的所有镜像，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker search</code>：从Docker Hub或其他仓库中搜索镜像，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker pull</code>：从Docker Hub或其他仓库中下载镜像到本地主机，可以指定镜像的名称和标签。</li>
<li><code>docker rmi</code>：删除本地主机上的一个或多个镜像，可以指定镜像的ID或名称和标签。</li>
<li><code>docker tag</code>：给本地主机上的一个镜像添加一个新的标签，可以指定源镜像和目标镜像的名称和标签。</li>
<li><code>docker build</code>：根据指定的Dockerfile文件来构建一个新的镜像，可以指定选项和上下文路径。</li>
<li><code>docker history</code>：查看一个镜像的创建历史，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker save</code>：将一个或多个镜像保存为一个tar归档文件，可以指定输出文件名或标准输出。</li>
<li><code>docker load</code>：从一个tar归档文件或标准输入中加载一个或多个镜像到本地主机。</li>
<li><code>docker import</code>：从一个tar归档文件或标准输入中导入一个容器快照为一个新的镜像，可以指定选项和目标镜像的名称和标签。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在使用Docker时，需要经常操作镜像，比如下载常用的基础镜像，删除不需要的镜像，创建自定义的镜像等。这些操作都需要用到上面介绍的命令。</li>
<li>在进行镜像备份或迁移时，需要用到<code>docker save</code>和<code>docker load</code>命令来保存和加载镜像文件。</li>
<li>在进行容器快照时，需要用到<code>docker import</code>命令来导入容器状态为一个新的镜像。</li>
</ul>
<h3 id="Docker容器管理"><a href="#Docker容器管理" class="headerlink" title="Docker容器管理"></a>Docker容器管理</h3><ul>
<li><code>docker run</code>：创建并启动一个新的容器，可以指定镜像、命令、参数、选项等。</li>
<li><code>docker ps</code>：查看当前运行的所有容器，可以指定选项来过滤或格式化输出结果。</li>
<li><code>docker start</code>：启动一个或多个已经创建的容器，可以指定容器的ID或名称。</li>
<li><code>docker stop</code>：停止一个或多个正在运行的容器，可以指定容器的ID或名称。</li>
<li><code>docker restart</code>：重启一个或多个容器，可以指定容器的ID或名称。</li>
<li><code>docker kill</code>：强制停止一个或多个正在运行的容器，可以指定容器的ID或名称。</li>
<li><code>docker rm</code>：删除一个或多个已经停止的容器，可以指定容器的ID或名称。</li>
<li><code>docker pause</code>：暂停一个或多个容器中的所有进程，可以指定容器的ID或名称。</li>
<li><code>docker unpause</code>：恢复一个或多个容器中的所有进程，可以指定容器的ID或名称。</li>
<li><code>docker create</code>：创建一个新的容器但不启动它，可以指定镜像、命令、参数、选项等。</li>
<li><code>docker exec</code>：在一个运行的容器中执行一个命令，可以指定选项和容器的ID或名称。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果想进入一个容器中，可以先执行docker ps 获取容器的ID或者名称</span></span><br><span class="line"><span class="comment"># docker exec -it 7963547123c00 bash 进入容器中</span></span><br><span class="line"><span class="comment"># 退出容器可以使用exit命令 或者ctrl+D</span></span><br></pre></td></tr></table></figure></li>
<li><code>docker logs</code>：查看一个容器的日志，可以指定选项和容器的ID或名称。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器运行日志</span></span><br><span class="line">docker logs -f canal</span><br></pre></td></tr></table></figure></li>
<li><code>docker inspect</code>：查看一个容器的详细信息，可以指定选项和格式化输出结果，可以指定容器的ID或名称。</li>
<li><code>docker top</code>：查看一个容器中运行的进程信息，可以指定选项和容器的ID或名称。</li>
<li><code>docker attach</code>：附加到一个运行的容器上，可以查看和操作标准输入输出流，可以指定容器的ID或名称。</li>
<li><code>docker events</code>：查看Docker服务器上发生的实时事件，可以指定过滤条件和时间范围。</li>
<li><code>docker wait</code>：阻塞直到一个或多个容器停止，然后打印出它们的退出代码，可以指定容器的ID或名称。</li>
<li><code>docker export</code>：将一个容器的文件系统导出为一个tar归档文件，可以指定输出文件名或标准输出，可以指定容器的ID或名称。</li>
<li><code>docker port</code>：查看一个指定的映射到私有端口上的公共端口，可以指定容器的ID或名称。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在使用Docker时，需要经常操作容器，比如创建并启动应用程序所需的环境，停止和删除不需要的环境等。这些操作都需要用到上面介绍的命令。</li>
<li>在进行容器监控和调试时，需要用到<code>docker logs</code>、<code>docker inspect</code>、<code>docker top</code>、<code>docker events</code>等命令来查看容器的日志、状态、进程、事件等信息。</li>
<li>在进行容器交互时，需要用到<code>docker exec</code>、<code>docker attach</code>等命令来在运行中的容器中执行命令或操作输入输出流。</li>
<li>在进行容器备份时，需要用到<code>docker export</code>命令来导出容器文件系统为一个tar归档文件。</li>
</ul>
<h3 id="Docker其他命令"><a href="#Docker其他命令" class="headerlink" title="Docker其他命令"></a>Docker其他命令</h3><p>除了上面介绍的三类命令外，Docker还提供了一些其他类型的命令，比如：</p>
<ul>
<li>网络管理：包括创建、删除、列出、检查、连接、断开Docker网络等命令。例如：<ul>
<li><code>docker network create</code>: 创建一个新的网络</li>
<li><code>docker network ls</code>: 列出所有网络</li>
<li><code>docker network inspect</code>: 查看网络详细信息</li>
<li><code>docker network rm</code>: 删除网络</li>
<li><code>docker network connect</code>: 连接一个网络到一个运行中的容器</li>
<li><code>docker network disconnect</code>: 从一个网络断开一个运行中的容器</li>
</ul>
</li>
<li>数据卷管理：包括创建、删除</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/" data-id="cljwriarr0001fgi74l4n7sp0" data-title="Docker命令汇总、最常用的也就这几句" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-试玩Canal，0入侵实现缓存同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2023-07-07T07:55:37.000Z" itemprop="datePublished">2023-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/">试玩Canal，零侵入实现缓存同步</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是canal"><a href="#什么是canal" class="headerlink" title="什么是canal"></a>什么是canal</h2><p>canal是一个基于MySQL二进制日志的高性能数据同步系统，可以将MySQL的增量数据订阅和消费，实现MySQL数据的实时同步。canal广泛用于阿里巴巴集团（包括 taobao.com ），以提供可靠的低延迟增量数据管道。canal的项目地址是：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="canal的工作原理"><a href="#canal的工作原理" class="headerlink" title="canal的工作原理"></a>canal的工作原理</h2><p>canal的工作原理是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。</p>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image.png" alt="Alt text"></p>
<h2 id="canal的优缺点"><a href="#canal的优缺点" class="headerlink" title="canal的优缺点"></a>canal的优缺点</h2><p>canal的优点是：</p>
<ul>
<li>部署简单，易于运维，适用于中小规模MySQL数据同步。</li>
<li>支持多种存储目的地，比如MySQL，Kafka，Elastic Search等等。</li>
<li>支持多种数据处理场景，比如数据库镜像、数据库实时备份、索引构建和实时维护、业务cache刷新、带业务逻辑的增量数据处理等等。</li>
<li>对代码的入侵性为0，不需要改动已有业务代码就可以实现数据备份</li>
</ul>
<p>canal的缺点是：</p>
<ul>
<li>同步的是增量数据，不会同步之前的存量数据。</li>
<li>单docker实例只能运行一个instance，如果需要运行多instance时，需要自行制作一份docker镜像。</li>
</ul>
<h2 id="如何快速在docker上安装部署一个canal"><a href="#如何快速在docker上安装部署一个canal" class="headerlink" title="如何快速在docker上安装部署一个canal"></a>如何快速在docker上安装部署一个canal</h2><p>在docker上安装部署一个canal的步骤如下：</p>
<ol>
<li><p>首先有一个MySQL服务器，并且开启binlog功能（开启binlog之后会牺牲mysql的一点点性能，总体来说利大于弊），并且配置binlog-format为ROW模式,在mysql的安装目录下找到my.cnf，添加配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin <span class="comment"># 开启 binlog</span></span><br><span class="line">binlog-format=ROW <span class="comment"># 选择 ROW 模式</span></span><br><span class="line">server_id=1 <span class="comment"># 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId </span></span><br><span class="line">binlog-do-db=test-db <span class="comment">#指定开启binlog的数据库名称，可以使多个。不设置默认开启全部</span></span><br></pre></td></tr></table></figure>
<p>修改后，需要重启mysql服务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重启后可以根据 查看bin_log的开启状态，以及保存路径</span></span><br><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-1.png" alt="Alt text"></p>
</li>
<li><p>在MySQL中创建一个用户，并授权SELECT, REPLICATION SLAVE, REPLICATION CLIENT权限。官网中的脚本可以直接执行,创建一个canal用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;canal&#x27;</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; ;</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="MySQL-binlog日志三种模式"><a href="#MySQL-binlog日志三种模式" class="headerlink" title="MySQL binlog日志三种模式"></a>MySQL binlog日志三种模式</h1><blockquote>
<p>这里插播一下STATEMENT，ROW，MIXED三种模式的区别，面试可能会涉及<br>MySQL binlog日志是用来记录MySQL数据库内部增删改等对数据库有更新内容的记录，主要用于数据库的主从复制和增量恢复。binlog日志有三种格式：STATEMENT，ROW，MIXED。这三种格式各有优缺点，根据不同的业务场景选择合适的格式。</p>
</blockquote>
<h2 id="binlog日志三种模式的优缺点"><a href="#binlog日志三种模式的优缺点" class="headerlink" title="binlog日志三种模式的优缺点"></a>binlog日志三种模式的优缺点</h2><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STATEMENT</td>
<td align="left">- binlog文件较小，节约磁盘IO，提高性能 <br> - binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况 <br> - binlog可以用于实时的还原，而不仅仅用于复制 <br> - 主从版本可以不一样，从服务器版本可以比主服务器版本高</td>
<td align="left">- 不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候 <br> - 调用具有不确定因素的UDF时复制也可能出问题 <br> - 使用以下函数的语句也无法被复制：LOAD_FILE ()，UUID ()，USER ()，FOUND_ROWS ()，SYSDATE ()等 <br> - INSERT … SELECT 会产生比 RBR 更多的行级锁 <br> - 复制需要进行全表扫描 (WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁 <br> - 对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句 <br> - 对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响 <br> - 存储函数 (不是存储过程)在被调用的同时也会执行一次 NOW () 函数，这个可以说是坏事也可能是好事 <br> - 确定了的 UDF 也需要在从服务器上执行 <br> - 数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错 <br> - 执行复杂语句如果出错的话，会消耗更多资源</td>
</tr>
<tr>
<td align="center">ROW</td>
<td align="left">- 任何情况都可以被复制，这对复制来说是最安全可靠的 <br> - 和其他大多数数据库系统的复制技术一样 <br> - 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多 <br> - 复制以下几种语句时的行锁更少：INSERT … SELECT ，包含 AUTO_INCREMENT 字段的 INSERT ，没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句 <br> - 执行 INSERT，UPDATE，DELETE 语句时锁更少 <br> - 从服务器上采用多线程来执行复制成为可能</td>
<td align="left">- binlog 大了很多 <br> - 主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题 <br> - UDF 产生的大 BLOB 值会导致复制变慢 <br> - 无法从 binlog 中看到都复制了写什么语句 <br> - 当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生</td>
</tr>
<tr>
<td align="center">MIXED</td>
<td align="left">- 以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式 <br> - 兼顾了binlog文件大小和复制安全性</td>
<td align="left">- 可能会导致主从服务器的数据不一致，因为不同的模式下，锁的粒度不一样</td>
</tr>
</tbody></table>
<h3 id="为什么配置binlog-format为ROW模式"><a href="#为什么配置binlog-format为ROW模式" class="headerlink" title="为什么配置binlog-format为ROW模式"></a>为什么配置binlog-format为ROW模式</h3><ul>
<li>canal在配置时需要将binlog-format设置为ROW模式，是因为canal需要解析MySQL的二进制日志，获取每一行数据的变化细节，以便实现数据的实时同步。</li>
<li>如果设置为其他两种模式，即STATEMENT或MIXED，会有以下问题：<ul>
<li>STATEMENT模式下，binlog只会记录和传输SQL语句，而不包含具体数据，canal无法保存和同步数据。</li>
<li>STATEMENT模式下，也会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>MIXED模式下，MySQL会根据执行的SQL语句选择日志保存方式，可能会导致主从服务器的数据不一致，因为不同的模式下，锁的粒度不一样。</li>
</ul>
</li>
</ul>
<h2 id="在Docker中快速搭建canal"><a href="#在Docker中快速搭建canal" class="headerlink" title="在Docker中快速搭建canal"></a>在Docker中快速搭建canal</h2><p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-2.png" alt="Alt text"><br>3. 从docker hub获取最新的canal镜像，并拉取到本地。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker pull canal/canal-server:v1.1.6</span><br><span class="line"><span class="comment"># 运行canal</span></span><br><span class="line">docker run -p 11111:11111 \</span><br><span class="line">--name canal \</span><br><span class="line">-e canal.destinations=zexx \</span><br><span class="line">-e canal.instance.mysql.slaveId=20230710 \</span><br><span class="line">-e canal.instance.master.address=192.168.1.6:3306 \</span><br><span class="line">-e canal.instance.dbUsername=canal \</span><br><span class="line">-e canal.instance.dbPassword=canal \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.filter.regex=zexx-hire-dev.data_dictionary \</span><br><span class="line">--restart=always \</span><br><span class="line">-d canal/canal-server:v1.1.6</span><br><span class="line"></span><br><span class="line"><span class="comment">#11111:11111：端口映射</span></span><br><span class="line"><span class="comment">#–name canal：容器名称</span></span><br><span class="line"><span class="comment">#–restart=always：自动重启</span></span><br><span class="line"><span class="comment">#canal.destinations：集群名称，给集群取一个名字</span></span><br><span class="line"><span class="comment">#canal.instance.mysql.slaveId：区别master的id，保证唯一</span></span><br><span class="line"><span class="comment">#canal.instance.master.address：mysql主数据库地址</span></span><br><span class="line"><span class="comment">#canal.instance.dbUsername/dbPassword：用户名和密码，也#就是之前上一节课所创建的用户以及授权，如果设置root用户其实也行。</span></span><br><span class="line"><span class="comment">#canal.instance.connectionCharset：字符集</span></span><br><span class="line"><span class="comment">#canal.instance.filter.regex：监听数据库数据表的表达式，多个可用逗号,连接</span></span><br><span class="line"><span class="comment">#以上环境变量如果不设置，也可以，但是需要在canal内部去修改canal-server配置也是OK的。</span></span><br></pre></td></tr></table></figure>
<p>启动完成之后，需要进入容器内</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it canal bash</span><br><span class="line"><span class="built_in">cd</span> /home/admin/canal-server/logs/xxx </span><br><span class="line"><span class="comment">## 下查看启动日志，验证是否启动成功。如果报错应该是链接数据库失败（可能会有mysql服务器地址不对，mysql用户密码策略、过期时间错误导致）</span></span><br></pre></td></tr></table></figure>

<h2 id="在springboot中集成"><a href="#在springboot中集成" class="headerlink" title="在springboot中集成"></a>在springboot中集成</h2><blockquote>
<p>因为canal是基于数据库层的解析，可以单独创建一个模块，与原有业务隔离完成，数据的操作。可以解决缓存同步、或者数据的问题。比如利用canal客户端更新缓存，或者同步数据，发送MQ消息等。<br>4. pom.xml文件添加依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.xml中添加canal相关配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">zexx</span> <span class="comment"># 空间名</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.6</span><span class="string">:11111</span> <span class="comment"># canal服务端地址</span></span><br><span class="line">  <span class="attr">user-name:</span> <span class="string">canal</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">canal</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">top.javatool.canal.client:</span> <span class="string">warn</span> <span class="comment"># 屏蔽监听日志的输入</span></span><br></pre></td></tr></table></figure>

<p>然后再编写监听类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zexx.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zexx.model.DataDictionary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *定义canal的监听类，用于接收canalserver同步的binlog信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CanalTable(&quot;data_dictionary&quot;)</span> <span class="comment">// 监听的表明</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDictSyncHelper</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;DataDictionary&gt; &#123;  <span class="comment">// 指定表的实体类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DataDictionary before, DataDictionary after)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改操作&quot;</span>);</span><br><span class="line">        System.out.println(before);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后&quot;</span>);</span><br><span class="line">        System.out.println(after);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataDictionary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(DataDictionary dataDictionary)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除操作&quot;</span>);</span><br><span class="line">        System.out.println(dataDictionary);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataDictionary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DataDictionary dataDictionary)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新增操作&quot;</span>);</span><br><span class="line">        System.out.println(dataDictionary);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新服务，修改数据库中对应的表，可以看到后台会打印相关日志。<br><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-3.png" alt="Alt text"><br>但是可以看到，很多字段的值都为空，这个是因为绑定的实体类的名称为驼峰命名，canal在解析时，无法对应字段。所以为空。需要重新绑定一个实体类即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zexx.model.co;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 数据字典表 CO 用于接收canal的同步消息</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zxwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-04-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDictionaryCO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String type_code;</span><br><span class="line">    <span class="keyword">private</span> String type_name;</span><br><span class="line">    <span class="keyword">private</span> String item_key;</span><br><span class="line">    <span class="keyword">private</span> String item_value;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新启动，解析成功</p>
<p><img src="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/image-4.png" alt="Alt text"></p>
<p>集成Redis或者ES、MQ之后，可以在对应的方法中进行业务操作</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">canal官方</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">canal-client官方</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langtianya/p/5504774.html">mysql中binlog_format模式与配置详解 - jack_ou - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/youzhibing/p/13131485.html">MySQL 日志之 binlog 格式 → 关于 MySQL 默认隔离级别的一些思考 - 如.若 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/67809.html">如何设置MySQL数据库备份的binlog_format - 阿里云</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96628405">史上最全的分布式数据同步中间间canal 之入门篇 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/440315272">Canal——Mysql的binlog最好的解决方案 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjerryj/article/details/77152226">使用 Binlog 和 Canal 从 MySQL 抽取数据 - CSDN博客</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/" data-id="cljwriart0005fgi7bu4nbu3i" data-title="试玩Canal，零侵入实现缓存同步" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" rel="tag">数据备份</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-高并发缓存三问-穿透、击穿、雪崩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" class="article-date">
  <time class="dt-published" datetime="2023-07-07T02:11:45.000Z" itemprop="datePublished">2023-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/">高并发缓存三问-穿透、击穿、雪崩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天聊一下面试的经典问题，缓存穿透，缓存击穿与缓存雪崩。</p>
<h1 id="缓存穿透、缓存击穿、缓存雪崩的总结"><a href="#缓存穿透、缓存击穿、缓存雪崩的总结" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩的总结"></a>缓存穿透、缓存击穿、缓存雪崩的总结</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">定义</th>
<th align="center">发生场景</th>
<th align="center">避免的手段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">缓存穿透</td>
<td align="center">请求的key在缓存和数据库中都不存在，导致请求直接打在数据库上</td>
<td align="center">有大量不存在的key被请求，可能是黑客攻击</td>
<td align="center">使用布隆过滤器或者把无效的key存进缓存</td>
</tr>
<tr>
<td align="center">缓存击穿</td>
<td align="center">请求的key是一个热点key，当这个key失效时，有大量并发请求打在数据库上</td>
<td align="center">热点key过期或者缓存重启</td>
<td align="center">对热点key设置永不过期或者使用互斥锁</td>
</tr>
<tr>
<td align="center">缓存雪崩</td>
<td align="center">大量的key在同一时间失效，导致大量请求打在数据库上</td>
<td align="center">缓存宕机或者设置了相同的过期时间</td>
<td align="center">在原有的失效时间上加上一个随机值，使用熔断机制，提高数据库和缓存的容灾能力</td>
</tr>
</tbody></table>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>大量Redis与数据库中匹配不到的key进行请求。导致数据库压力过大，打死。</p>
</blockquote>
<p><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="Alt text"></p>
<h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><blockquote>
<p>方案一：进行添加布隆过滤器,布隆过滤器会将匹配不到的key直接返回。因为布隆过滤器的存储和判断机制，对判断某一个key一定存在有一定的误判率，无法做到百分之百的精准匹配。所以需要根据场景使用。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="Alt text"></p>
</blockquote>
<blockquote>
<p>方案二，key第一次请求时，如果Redis匹配失败，去查询数据库返回null.这将这个空对象进行Redis保存。但是要设置一定的失效时间。</p>
</blockquote>
<h3 id="布隆过滤器机制"><a href="#布隆过滤器机制" class="headerlink" title="布隆过滤器机制"></a>布隆过滤器机制</h3><blockquote>
<p>布隆过滤器是一个由0和1组成二进制数组，所以他不会占用太多内存，就可以实现数据的过滤。</p>
</blockquote>
<ul>
<li>请求中的key会根据hash算法，在二进制数组中进行匹配。比如每一个subCat都是根据三个位置判断是否有效的，如果三个点都是1则表示存在。</li>
<li>但是匹配时，会有数据相交的地方。比如说下图的第三个节点，就是subCat1与subCat2相同的位置。</li>
<li>此时有一个subCat虽然他的key是不存在的。但是根据hash算法解析后，他匹配的数组位置恰好都是1.则布隆过滤器会认为这个key是存在的。则出现了误判。这个误判只对判断一个key是否存在时会产生。</li>
</ul>
<p><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image.png" alt="Alt text"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<p>一个热点的key,在一个高并发的场景下。进行请求，此时Redis中的缓存刚好失效，或者还未生成。导致该场景下的所有请求都绕过了缓存直接请求数据库。导致数据库压力过大直接打死。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image2.png" alt="Alt text"></p>
</blockquote>
<h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><ul>
<li>单线程 setnx<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image-1.png" alt="Alt text"><blockquote>
<p>Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值.存在时设置值会失败。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>因为Redis在接收请求时是单线程的。用户所有的请求都需要排队访问Redis。第一个请求进来时，先判断key是否存在，如果不存在，则setnx一个默认的值，然后请求数据库，然后将返回的数据更新Redis中的数据。此时后续的请求也可以先进行setnx，如果失败，就先等待，一直等到Redis中的数据重新更新成功之后，再放行。这样无论并发场景有多高，访问数据库的次数只有一次。</p>
</blockquote>
<ul>
<li><p>多线程 定期检查。使用一个线程，定时检查数据库中的数据是否在Redis存在。如果没有则进行Redis初始数据。次方法只能针对已知的热点key。</p>
</li>
<li><p>缓存永不过期 </p>
</li>
<li><p>缓存预热</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大量的key在同一时间失效，导致大量请求打在数据库上。导致数据库崩溃。<br><img src="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/image-3.png" alt="Alt text"></p>
<h3 id="预防措施-2"><a href="#预防措施-2" class="headerlink" title="预防措施"></a>预防措施</h3><ul>
<li><p>添加失效时间时，增加随机数。这样可以避免同一时间Redis出现大量缓存数据同时失效。</p>
</li>
<li><p>将数据设置为永不过期</p>
</li>
<li><p>多缓存结合</p>
</li>
<li><p>使用熔断机制，提高数据库和缓存的容灾能力</p>
</li>
</ul>
<p>: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346651831">参考-什么是缓存雪崩、缓存击穿、缓存穿透？ - 知乎</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" data-id="cljwriary000ofgi77aspail6" data-title="高并发缓存三问-穿透、击穿、雪崩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CodeWhisperer自动编程的插件试玩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/" class="article-date">
  <time class="dt-published" datetime="2023-07-06T08:00:57.000Z" itemprop="datePublished">2023-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/">CodeWhisperer自动编程的插件试玩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="安装试用一下自动编程软件"><a href="#安装试用一下自动编程软件" class="headerlink" title="安装试用一下自动编程软件"></a>安装试用一下自动编程软件</h1><p>程序员实现面向注释编程不是梦</p>
<h1 id="Copilot-vs-CodeWhisperer"><a href="#Copilot-vs-CodeWhisperer" class="headerlink" title="Copilot vs CodeWhisperer"></a>Copilot vs CodeWhisperer</h1><p>Copilot和CodeWhisperer都是基于AI的编程辅助工具，它们可以根据开发者的注释或输入，自动提供代码建议。它们有很多相似之处，但也有一些不同之处，这些不同之处可能会影响你选择使用哪一个工具。下面是一个简单的对比表格，列举了它们的一些主要特点和区别。</p>
<table>
<thead>
<tr>
<th>Copilot</th>
<th>CodeWhisperer</th>
</tr>
</thead>
<tbody><tr>
<td>由GitHub（属于微软）开发，于2021年6月发布测试版，2022年6月正式上线</td>
<td>由亚马逊开发，于2022年6月发布测试版</td>
</tr>
<tr>
<td>基于OpenAI Codex模型，该模型是一个大规模的神经网络，可以生成自然语言和代码</td>
<td>基于亚马逊内部的AI模型，该模型的细节尚未公开</td>
</tr>
<tr>
<td>使用公开的源代码库进行训练，包括GitHub上的数十亿行代码</td>
<td>使用公开和私有的源代码库进行训练，包括亚马逊内部的代码</td>
</tr>
<tr>
<td>支持多种编程语言和框架，目前优化了Python, JavaScript, TypeScript, Ruby, Go, C#, C++等语言</td>
<td>Python、Java、JavaScript、TypeScript、C#、Rust、Go、Ruby、Scala、Kotlin、PHP、C、C++、Shell 脚本编写、SQL。</td>
</tr>
<tr>
<td>支持多种IDE，如Visual Studio, Neovim, VS Code, JetBrains等，也可以在网页上使用</td>
<td>目前，仅在适用于 Python、Java 和 JavaScript 的 VS Code 和 JetBrains IDE 中支持代码安全扫描。</td>
</tr>
<tr>
<td>收费10美元&#x2F;月或100美元&#x2F;年，学生和开源项目贡献者可免费使用</td>
<td>个人免费使用，企业与专业版许付费</td>
</tr>
</tbody></table>
<p>总的来说，Copilot是一个更通用的AI编程辅助工具，而CodeWhisperer是一个更专注于AWS平台的工具。你可以根据你的需求和喜好来选择使用哪一个工具。</p>
<h1 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h1><p>Copilot 可以免费试用30天，但是需要绑定信用卡，想想还是算了。可以用，但是没必要。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/features/copilot">https://github.com/features/copilot</a></p>
</blockquote>
<h1 id="CodeWhisperer"><a href="#CodeWhisperer" class="headerlink" title="CodeWhisperer"></a>CodeWhisperer</h1><p>这个目前是免费的，注册一下玩玩。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/codewhisperer/resources/#Getting_started">https://aws.amazon.com/cn/codewhisperer/resources/#Getting_started</a></p>
</blockquote>
<p>在IDEA插件市场搜索，aws。然后选择AWS Toolkit进行安装<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image.png" alt="Alt text"><br>安装完成之后，侧边会显示aws图标。然后会提示你进行登录<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-2.png" alt="Alt text"><br>选择复制编码登录，然后粘贴复制的编码，创建账号<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-3.png" alt="Alt text"><br>这里会有一个邮箱的验证码认证，验证成功之后，可以重新打开IDEA窗口，然后就可以启动CodeWhisperer了<br><img src="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/image-4.png" alt="Alt text"><br>使用了一下，感觉有些卡顿。人机交互的感觉不是很好。AI不是很懂我的样子。可以实现一些简单的日常的算法。能提高一些开发效率。多多少少可以挽救几根头发。对于写代码不喜欢加注释的童鞋，是一个好的工具</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/" data-id="cljwriaro0000fgi7bzvafiwq" data-title="CodeWhisperer自动编程的插件试玩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/">后端知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" rel="tag">数据备份</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 20px;">开发工具</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" style="font-size: 10px;">数据备份</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/07/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a>
          </li>
        
          <li>
            <a href="/2023/07/10/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B9%9F%E5%B0%B1%E5%87%A0%E5%8F%A5/">Docker命令汇总、最常用的也就这几句</a>
          </li>
        
          <li>
            <a href="/2023/07/07/%E8%AF%95%E7%8E%A9Canal%EF%BC%8C0%E5%85%A5%E4%BE%B5%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/">试玩Canal，零侵入实现缓存同步</a>
          </li>
        
          <li>
            <a href="/2023/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE-%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/">高并发缓存三问-穿透、击穿、雪崩</a>
          </li>
        
          <li>
            <a href="/2023/07/06/CodeWhisperer%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AF%95%E7%8E%A9/">CodeWhisperer自动编程的插件试玩</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 zex<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>